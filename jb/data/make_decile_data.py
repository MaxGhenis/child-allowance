# -*- coding: utf-8 -*-
"""child_allowance_distributional_impact.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15O7GKYztNVAXtS6uuo-Y_XCawjLJ3qz-

# Distributional impact of tax-funded child allowance by state

Approach:
* Calculate SPM resources, people, children (people under 18) and taxable income per SPM unit
* Calculate deciles of SPM resources per person, both nationally and by state [TODO: Adjust numbers for inflation across years.]
* Calculate taxable income per child for each state, and merge that back to the person dataframe
* Calculate the change in income per dollar of child allowance for each person, using SPM columns
* Aggregate to SPM unit
"""

!pip install git+https://github.com/pslmodels/microdf.git
!pip install us

import microdf as mdf
import pandas as pd
import numpy as np
import us

"""## Load data"""

raw = pd.read_csv('https://github.com/ngpsu22/State_Child_Allowance_Income_Tax/raw/master/cps_00022.csv.gz')

"""## Define functions

Assign state and federal income deciles based on SPM resources per person.
"""

df = raw.copy(deep=True)

"""Cleanup."""

df.columns = df.columns.str.lower()
df.taxinc = np.where(df.taxinc == 9999999, 0, df.taxinc)
df.adjginc = np.where(df.adjginc == 99999999, 0, df.adjginc)
df.asecwt /= 3  # 3 years
df.spmwt /= 3
df['child'] = df.age < 18
df['person'] = 1
df['state'] = df.statefip.apply(
    lambda x: us.states.lookup(str(x).zfill(2)).name).tolist()

"""Aggregate to SPM unit."""

df.columns

spmu = pd.DataFrame(df.groupby(['spmfamunit', 'year', 'state', 'spmwt', 'spmtotres'])[
    ['child', 'person', 'taxinc']].sum()).reset_index()
# Calculate weight that represents number of people.
# Note: no longer used.
spmu['wt'] = spmu.spmwt * spmu.person
spmu['spm_resources_pp'] = spmu.spmtotres / spmu.person
# spmu.columns = ['spm_child', 'spm_person', 'spm_taxinc']
mdf.add_weighted_quantiles(spmu, 'spm_resources_pp', 'spmwt')
spmu.drop(['spm_resources_pp_percentile', 'spm_resources_pp_2percentile',
           'spm_resources_pp_ventile', 'spm_resources_pp_quintile',
           'spm_resources_pp_quartile'],
          axis=1, inplace=True)
# Include negatives in the first decile.
# TODO: Make this an option in microdf.
spmu.spm_resources_pp_decile = np.maximum(spmu.spm_resources_pp_decile, 1)

spmu.groupby('spm_resources_pp_decile')[['wt', 'spmwt']].sum()

"""Now for state."""

states = df.state.unique()
l = []
for state in states:
    # Get row and spm_resources_pp_decile_state
    tmp = spmu[spmu.state == state].copy(deep=True)
    mdf.add_weighted_quantiles(tmp, 'spm_resources_pp', 'spmwt')
    l.append(tmp.spm_resources_pp_decile)
state_decile = pd.concat(l).rename('spm_resources_pp_decile_state')
state_decile = np.maximum(state_decile, 1)

spmu = spmu.join(pd.DataFrame(state_decile))

spmu

"""## Calculate necessary amount per state

NB: These are all weighted by SPM unit, not individuals.
"""

# TODO: Support multiple columns in mdf.weighted_sum, with a groupby.
taxinc_state = spmu.groupby('state').apply(
    lambda x: mdf.weighted_sum(x, 'taxinc', 'spmwt')
)
taxinc_state.name = 'taxinc'
children_state = spmu.groupby('state').apply(
    lambda x: mdf.weighted_sum(x, 'child', 'spmwt')
)
children_state.name = 'children'
state = taxinc_state.to_frame().join(children_state)
state['state_taxinc_per_child'] = state.taxinc / state.children
spmu2 = spmu.merge(state[['state_taxinc_per_child']], left_on='state',
                   right_index=True)

"""Calculate change per dollar of child allowance.

NB: These are weighted by
"""

total_taxinc = mdf.weighted_sum(spmu2, 'taxinc', 'spmwt')
total_children = mdf.weighted_sum(spmu2, 'child', 'spmwt')
fed_taxinc_per_child = total_taxinc / total_children
fed_taxinc_per_child

"""Since each dollar of child allowance equals the number of children, a SPM unit's tax per dollar of child allowance equals their taxable income divided by the overall taxable income per child.

For example, a SPM unit with average income within the country or state will pay that average amount, and any deviations from that will be in proportion to income.
"""

spmu2

spmu2['tax_per_dollar_ca_fed'] = spmu2.taxinc / fed_taxinc_per_child
spmu2['net_per_dollar_ca_fed'] = spmu2.child - spmu2.tax_per_dollar_ca_fed
spmu2['tax_per_dollar_ca_state'] = spmu2.taxinc / spmu2.state_taxinc_per_child
spmu2['net_per_dollar_ca_state'] = spmu2.child - spmu2.tax_per_dollar_ca_state

# Check that it nets out, both overall and by decile.
assert np.allclose(0, mdf.weighted_mean(spmu2, 'net_per_dollar_ca_fed', 'spmwt'))
assert np.allclose(
    0,
    spmu2.groupby('spm_resources_pp_decile').apply(
        lambda x: mdf.weighted_mean(x, 'net_per_dollar_ca_fed', 'spmwt')).mean(),
    atol=1e-5)

"""## Calculate data for each state

Should have these columns:
* state
* fed/state funding
* decile
* net_per_dollar_ca
"""

# Federal
fed_deciles = spmu2.groupby(['spm_resources_pp_decile', 'state']).apply(
    lambda x: mdf.weighted_mean(x, 'net_per_dollar_ca_fed',
                                'spmwt')).to_frame().reset_index()
fed_deciles['funding'] = 'federal'
# State
state_deciles = spmu2.groupby(['spm_resources_pp_decile_state', 'state']).apply(
    lambda x: mdf.weighted_mean(x, 'net_per_dollar_ca_state',
                                'spmwt')).to_frame().reset_index()
state_deciles['funding'] = 'state'
state_deciles.rename({'spm_resources_pp_decile_state':
                      'spm_resources_pp_decile'}, axis=1, inplace=True)

"""US with federal funding."""

us_fed_deciles = spmu2.groupby(['spm_resources_pp_decile']).apply(
    lambda x: mdf.weighted_mean(x, 'net_per_dollar_ca_fed',
                                'spmwt')).to_frame().reset_index()
us_fed_deciles['funding'] = 'federal'
us_fed_deciles['state'] = 'US'
us_state_deciles = spmu2.groupby(['spm_resources_pp_decile_state']).apply(
    lambda x: mdf.weighted_mean(x, 'net_per_dollar_ca_state',
                                'spmwt')).to_frame().reset_index()
us_state_deciles['funding'] = 'state'
us_state_deciles['state'] = 'US'
us_state_deciles.rename({'spm_resources_pp_decile_state':
                         'spm_resources_pp_decile'}, axis=1, inplace=True)

deciles_combined = pd.concat([fed_deciles, state_deciles, us_fed_deciles,
                              us_state_deciles]).rename(
    {0: 'net_per_dollar_ca_state'}, axis=1)
deciles_combined

"""Replicate for each monthly child allowance amount."""

l = []
for i in np.arange(0, 501, 25):
    tmp = deciles_combined.copy(deep=True)
    tmp['monthly_ca'] = i
    tmp['net_chg'] = i * 12 * tmp.net_per_dollar_ca_state
    l.append(tmp)
ca_state_decile = pd.concat(l)
ca_state_decile

"""## Plot

Just plot one for now
"""

import plotly.express as px

test = ca_state_decile.query('state == "US" & funding == "federal"').round()

test.net_per_dollar_ca_state.sum()

assert np.allclose(0, test.net_per_dollar_ca_state.sum(), atol=0.01)

"""Each decile has an equal number of people."""

# Make chart symmetric with boundary at the maximum.
boundary = ca_state_decile.net_chg.agg([min, max]).abs().max()

fig = px.bar(test, x='spm_resources_pp_decile',
             y='net_chg',
             animation_frame='monthly_ca')
fig.update_layout(
    title='Average net change per dollar child allowance by decile',
    xaxis_title='Decile of resources per person',
    yaxis_title='Average net change per dollar child allowance',
    yaxis_tickprefix='$',
    plot_bgcolor='white',
    font=dict(family='Roboto')
)
fig.update_yaxes(range=[-boundary, boundary])
fig.update_traces(hovertemplate=None)
fig.show()

ca_state

"""## Appendix

Check that state and federal deciles are similar.
"""

df.pivot_table('asecwt', 'spm_resources_pp_decile',
               'spm_resources_pp_decile_state')

"""Share with the same state and federal decile."""

df[df.spm_resources_pp_decile == df.spm_resources_pp_decile_state].asecwt.sum() / df.asecwt.sum()